import * as fs from 'fs';
import * as path from 'path';
import * as cp from 'child_process';
import * as vscode from 'vscode';

import { detectPackageManager } from './packageManager';
import { detectNextjsAppDir, getNextjsLayout, isAggoGeneratedFile, type NextjsCodegenOptions, AGGO_GENERATED_TAG } from './nextjsCodegen';
import { computeSchemaPathLiteral, upsertResolverRegion } from './graphqlResolverScaffold';

async function ensureDir(dirPath: string): Promise<void> {
  await fs.promises.mkdir(dirPath, { recursive: true });
}

async function safeReadText(filePath: string): Promise<string | undefined> {
  try {
    return await fs.promises.readFile(filePath, 'utf8');
  } catch {
    return undefined;
  }
}

async function writeText(filePath: string, contents: string): Promise<void> {
  await ensureDir(path.dirname(filePath));
  await fs.promises.writeFile(filePath, contents, 'utf8');
}

async function ensureRuntimeGraphqlDeps(runtimeRootAbs: string): Promise<void> {
  const runtimePkgPath = path.join(runtimeRootAbs, 'package.json');
  if (!fs.existsSync(runtimePkgPath)) return;

  let runtimePkg: any;
  try {
    runtimePkg = JSON.parse(await fs.promises.readFile(runtimePkgPath, 'utf8'));
  } catch {
    return;
  }

  const deps = runtimePkg?.dependencies ?? {};
  const devDeps = runtimePkg?.devDependencies ?? {};
  const hasGraphql = Boolean(deps['graphql'] || devDeps['graphql']);
  const hasYoga = Boolean(deps['graphql-yoga'] || devDeps['graphql-yoga']);
  if (hasGraphql && hasYoga) return;

  const ok = await vscode.window.showInformationMessage(
    'Aggo: Next.js runtime needs GraphQL dependencies (graphql, graphql-yoga) for the generated GraphQL route. Install them now?'
    ,
    { modal: true },
    'Install'
  );
  if (ok !== 'Install') return;

  const pm = detectPackageManager(runtimeRootAbs);
  const cmd = pm === 'pnpm' ? 'pnpm' : pm === 'yarn' ? 'yarn' : 'npm';
  const args = pm === 'pnpm'
    ? ['add', 'graphql', 'graphql-yoga']
    : pm === 'yarn'
      ? ['add', 'graphql', 'graphql-yoga']
      : ['install', '--save', 'graphql', 'graphql-yoga'];

  await new Promise<void>((resolve, reject) => {
    const child = cp.spawn(cmd, args, { cwd: runtimeRootAbs, env: process.env, stdio: 'inherit' });
    child.on('error', reject);
    child.on('exit', (code: number) => {
      if (code === 0) resolve();
      else reject(new Error(`${cmd} exited with code ${code}`));
    });
  });
}
async function ensureUserResolversFile(opts: NextjsCodegenOptions, resolverIds: string[]): Promise<void> {
  const userPath = path.join(opts.runtimeCwdAbs, 'src', 'aggo', 'user', 'graphql-resolvers.ts');
  const existing = await safeReadText(userPath);

  const { updated, changed } = upsertResolverRegion(existing, resolverIds);
  if (!existing || changed) {
    await writeText(userPath, updated);
  }
}

async function ensureGeneratedModules(opts: NextjsCodegenOptions): Promise<void> {
  const layout = getNextjsLayout(opts);
  await ensureDir(layout.generatedDir);

  const wrappers: Array<{ name: string; contents: string }> = [
    {
      name: 'graphql-resolvers.ts',
      contents: `// ${AGGO_GENERATED_TAG}\n// Generated by the Aggo VS Code extension.\n\nexport { resolverRegistry } from '@/aggo/user/graphql-resolvers';\nexport type { ResolverFn } from '@/aggo/user/graphql-resolvers';\n`
    },
    {
      name: 'graphqlSchemaPath.ts',
      contents: `// ${AGGO_GENERATED_TAG}\n// Generated by the Aggo VS Code extension.\n\n// Default schema path. The extension updates this when you open a schema in the GraphQL editor.\nexport const schemaPath = process.env.AGGO_GRAPHQL_SCHEMA_PATH || 'schema.graphql';\n`
    }
  ];

  for (const w of wrappers) {
    const p = path.join(layout.generatedDir, w.name);
    const existing = await safeReadText(p);
    if (!existing || isAggoGeneratedFile(existing)) {
      await writeText(p, w.contents);
    }
  }
}

async function ensureSchemaPathWiring(opts: NextjsCodegenOptions, schemaPathOrUri?: string): Promise<void> {
  if (!schemaPathOrUri) return;
  const layout = getNextjsLayout(opts);
  const outPath = path.join(layout.generatedDir, 'graphqlSchemaPath.ts');
  const existing = await safeReadText(outPath);
  if (existing && !isAggoGeneratedFile(existing)) return;

  const schemaFsPath = schemaPathOrUri.startsWith('file:') ? vscode.Uri.parse(schemaPathOrUri).fsPath : schemaPathOrUri;
  const relLiteral = computeSchemaPathLiteral({ runtimeRootAbs: opts.runtimeCwdAbs, schemaFsPath });

  const contents = `// ${AGGO_GENERATED_TAG}\n// Generated by the Aggo VS Code extension.\n\n// Used by the generated Next.js GraphQL route to load the workspace schema.\nexport const schemaPath = process.env.AGGO_GRAPHQL_SCHEMA_PATH || ${JSON.stringify(relLiteral)};\n`;
  await writeText(outPath, contents);
}

async function ensureGraphqlRoute(opts: NextjsCodegenOptions): Promise<void> {
  const appDir = detectNextjsAppDir(opts.runtimeCwdAbs);
  const routePath = path.join(appDir, 'aggo', 'graphql', 'route.ts');
  const existing = await safeReadText(routePath);
  if (existing && !isAggoGeneratedFile(existing)) return;

  const contents = `// ${AGGO_GENERATED_TAG}\n// Generated by the Aggo VS Code extension.\n// Next.js App Router endpoint: /aggo/graphql\n\nexport const runtime = 'nodejs';\n\nimport fs from 'node:fs';\nimport { createYoga, createSchema } from 'graphql-yoga';\nimport { parse, Kind } from 'graphql';\n\nimport { schemaPath } from '@/aggo/generated/graphqlSchemaPath';\nimport { resolverRegistry } from '@/aggo/user/graphql-resolvers';\n\ntype ResolverMap = Record<string, Record<string, any>>;\n\nfunction readSchemaSDL(): string {
  try {
    return fs.readFileSync(schemaPath, 'utf8');
  } catch (e) {
    console.warn('[aggo] failed reading schema at', schemaPath, e);
    return 'type Query { _empty: String }';
  }
}\n\nfunction getStringArg(d: any, name: string): string | undefined {
  const a = Array.isArray(d?.arguments) ? d.arguments.find((x: any) => x?.name?.value === name) : undefined;
  if (!a) return undefined;
  const v = a.value;
  if (v?.kind === Kind.STRING) return v.value;
  return undefined;
}\n\nfunction buildResolversFromDirectives(typeDefs: string): ResolverMap {
  const resolvers: ResolverMap = {};
  const doc = parse(typeDefs);
\n  for (const def of doc.definitions) {
    if (def.kind !== Kind.OBJECT_TYPE_DEFINITION && def.kind !== Kind.OBJECT_TYPE_EXTENSION) continue;
    const typeName = def.name?.value;
    if (!typeName) continue;
    if (!Array.isArray((def as any).fields)) continue;
\n    for (const field of (def as any).fields) {
      const fieldName = field?.name?.value;
      if (!fieldName) continue;
      const directives = Array.isArray(field.directives) ? field.directives : [];
\n      for (const dir of directives) {
        const dname = dir?.name?.value;
        if (!dname) continue;
\n        if (dname === 'resolver') {
          const id = getStringArg(dir, 'name');
          if (!id) continue;
          const fn = (resolverRegistry as any)[id];
          if (typeof fn !== 'function') {
            console.warn('[aggo] resolver id not found in resolverRegistry:', id);
            continue;
          }
          resolvers[typeName] = resolvers[typeName] || {};
          resolvers[typeName][fieldName] = fn;
        }
\n        if (dname === 'http') {
          const url = getStringArg(dir, 'url');
          const method = (getStringArg(dir, 'method') || 'GET').toUpperCase();
          if (!url) continue;
          resolvers[typeName] = resolvers[typeName] || {};
          resolvers[typeName][fieldName] = async (parent: any, args: any, ctx: any) => {
            const finalUrl = url.replace(/\{\{\s*source\.([a-zA-Z0-9_]+)\s*\}\}/g, (_m, k) => encodeURIComponent(String(parent?.[k] ?? '')));
            const res = await fetch(finalUrl, { method });
            const contentType = res.headers.get('content-type') || '';
            if (contentType.includes('application/json')) return res.json();
            return res.text();
          };
        }
      }
    }
  }
\n  return resolvers;
}\n\nconst yoga = createYoga({
  graphqlEndpoint: '/aggo/graphql',
  schema: (() => {
    const typeDefs = readSchemaSDL();
    const resolvers = buildResolversFromDirectives(typeDefs);
    return createSchema({ typeDefs, resolvers });
  })()
});\n\nexport { yoga as GET, yoga as POST };\n`;

  await writeText(routePath, contents);
}

export async function syncGraphqlRuntimeAddons(
  opts: NextjsCodegenOptions,
  schemaPathOrUri?: string,
  resolverIds: string[] = []
): Promise<void> {
  // Ensure runtime project exists.
  if (!fs.existsSync(opts.runtimeCwdAbs)) return;

  // Ensure deps in runtime (prompt user).
  await ensureRuntimeGraphqlDeps(opts.runtimeCwdAbs);

  // Scaffold runtime files.
  await ensureGeneratedModules(opts);
  await ensureSchemaPathWiring(opts, schemaPathOrUri);
  await ensureUserResolversFile(opts, resolverIds);
  await ensureGraphqlRoute(opts);
}
