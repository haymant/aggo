import * as fs from 'fs';
import * as path from 'path';

export const AGGO_GENERATED_TAG = '@aggo-generated';

export type NextjsRuntimeLayout = {
  runtimeRoot: string;
  appDir: string;
  generatedDir: string;
};

export type NextjsCodegenOptions = {
  workspaceRoot: string;
  runtimeCwdAbs: string;
  /** If provided, used to confirm potentially-destructive operations. */
  confirm?: (message: string, kind: 'overwrite' | 'delete') => Promise<boolean>;
};

export function detectNextjsAppDir(runtimeRoot: string): string {
  const srcApp = path.join(runtimeRoot, 'src', 'app');
  if (fs.existsSync(srcApp)) return srcApp;
  const app = path.join(runtimeRoot, 'app');
  if (fs.existsSync(app)) return app;
  // Default for create-next-app when using --src-dir is src/app.
  return srcApp;
}

export function getNextjsLayout(opts: NextjsCodegenOptions): NextjsRuntimeLayout {
  const appDir = detectNextjsAppDir(opts.runtimeCwdAbs);
  const generatedDir = path.join(opts.runtimeCwdAbs, 'src', 'aggo', 'generated');
  return { runtimeRoot: opts.runtimeCwdAbs, appDir, generatedDir };
}

export function normalizePageId(pageId: string): string {
  return pageId
    .split('\\').join('/')
    .replace(/^\/+/, '')
    .replace(/\/+$/, '');
}

export function routeDirForPageId(appDir: string, pageId: string): string {
  const id = normalizePageId(pageId);
  const segments = id.length ? id.split('/') : ['index'];
  return path.join(appDir, 'aggo', 'page', ...segments);
}

export function isAggoGeneratedFile(contents: string): boolean {
  return contents.includes(AGGO_GENERATED_TAG);
}

async function safeReadText(filePath: string): Promise<string | undefined> {
  try {
    return await fs.promises.readFile(filePath, 'utf8');
  } catch {
    return undefined;
  }
}

async function ensureDir(dirPath: string): Promise<void> {
  await fs.promises.mkdir(dirPath, { recursive: true });
}

async function writeText(filePath: string, contents: string): Promise<void> {
  await ensureDir(path.dirname(filePath));
  await fs.promises.writeFile(filePath, contents, 'utf8');
}

export async function ensureRuntimeGeneratedFiles(opts: NextjsCodegenOptions): Promise<void> {
  const layout = getNextjsLayout(opts);
  await ensureDir(layout.generatedDir);

  const loadPagePath = path.join(layout.generatedDir, 'loadPage.ts');
  const rendererPath = path.join(layout.generatedDir, 'renderer.tsx');

  const loadPage = `// ${AGGO_GENERATED_TAG}
// This file is generated by the Aggo VS Code extension.
// It loads *.page JSON files from the workspace and returns the parsed element tree.

import * as path from 'path';
import * as fs from 'fs/promises';

export type AggoPageElement = {
  id: string;
  tagName: string;
  attributes?: Record<string, string>;
  styles?: Record<string, string>;
  content?: string;
  children?: AggoPageElement[];
  // future: events/lifecycle/store
};

export async function loadAggoPageFromWorkspace(args: { workspaceRoot: string; pageId: string }): Promise<AggoPageElement> {
  // Strip leading slashes without using a regex literal to avoid tooling/parser edge cases.
  let pageId = args.pageId || '';
  while (pageId.startsWith('/')) pageId = pageId.slice(1);
  const filePath = path.join(args.workspaceRoot, 'resources', 'page', pageId + '.page');
  const raw = await fs.readFile(filePath, 'utf8');
  return JSON.parse(raw) as AggoPageElement;
}
`;

  const renderer = `// ${AGGO_GENERATED_TAG}
// This file is generated by the Aggo VS Code extension.
// It renders Aggo *.page element JSON into React elements.

import * as React from 'react';
import type { AggoPageElement } from './loadPage';

function normalizeDomAttributes(attrs: Record<string, string>): Record<string, any> {
  const out: Record<string, any> = {};
  for (const [k, v] of Object.entries(attrs ?? {})) {
    if (k === 'class') {
      if (!('className' in attrs)) out.className = v;
      continue;
    }
    if (k === 'for') {
      if (!('htmlFor' in attrs)) out.htmlFor = v;
      continue;
    }
    out[k] = v;
  }
  return out;
}

export function AggoElementRenderer(props: { element: AggoPageElement }): React.ReactElement {
  const el = props.element;
  const children = (el.children ?? []).map((c) => React.createElement(AggoElementRenderer, { key: c.id, element: c }));

  const tag: any = el.tagName || 'div';
  const attrs = normalizeDomAttributes(el.attributes ?? {});
  const style = (el.styles ?? {}) as any;

  const voidElements = new Set(['img', 'input', 'hr', 'br']);
  if (voidElements.has(String(tag).toLowerCase())) {
    return React.createElement(tag, { ...attrs, style });
  }

  // NOTE: Runtime event wiring, lifecycle, and store are intentionally not implemented here yet.
  // They will be generated into separate modules and wired by convention.

  if (typeof el.content === 'string' && children.length === 0) {
    return React.createElement(tag, { ...attrs, style }, el.content);
  }

  return React.createElement(tag, { ...attrs, style }, ...children);
}
`;

  const existingLoadPage = await safeReadText(loadPagePath);
  if (!existingLoadPage || isAggoGeneratedFile(existingLoadPage)) {
    await writeText(loadPagePath, loadPage);
  }

  const existingRenderer = await safeReadText(rendererPath);
  if (!existingRenderer || isAggoGeneratedFile(existingRenderer)) {
    await writeText(rendererPath, renderer);
  }
}

function routePageTsx(args: { workspaceRoot: string; pageId: string }): string {
  const id = normalizePageId(args.pageId);
  return `// ${AGGO_GENERATED_TAG}
// Route for /aggo/page/${id}
// Generated by Aggo VS Code extension. Do not hand-edit unless you remove the ${AGGO_GENERATED_TAG} tag.

import { AggoElementRenderer } from '@/aggo/generated/renderer';
import { loadAggoPageFromWorkspace } from '@/aggo/generated/loadPage';

export default async function AggoPageRoute() {
  const element = await loadAggoPageFromWorkspace({ workspaceRoot: ${JSON.stringify(args.workspaceRoot)}, pageId: ${JSON.stringify(id)} });
  const wrapperStyle: React.CSSProperties = {
    minHeight: '100vh',
    backgroundColor: element?.styles?.backgroundColor ?? '#ffffff',
    color: element?.styles?.color ?? '#000000'
  };
  return (
    <div style={wrapperStyle}>
      <AggoElementRenderer element={element} />
    </div>
  );
}
`;
}

export async function ensureRouteForPageId(opts: NextjsCodegenOptions, pageId: string): Promise<void> {
  const layout = getNextjsLayout(opts);
  await ensureRuntimeGeneratedFiles(opts);

  const dir = routeDirForPageId(layout.appDir, pageId);
  const filePath = path.join(dir, 'page.tsx');
  const nextContents = routePageTsx({ workspaceRoot: opts.workspaceRoot, pageId });

  const existing = await safeReadText(filePath);
  if (!existing) {
    await writeText(filePath, nextContents);
    return;
  }

  if (isAggoGeneratedFile(existing)) {
    await writeText(filePath, nextContents);
    return;
  }

  if (opts.confirm) {
    const ok = await opts.confirm(`Next.js route already exists and is not marked as generated: ${path.relative(opts.runtimeCwdAbs, filePath)}. Overwrite?`, 'overwrite');
    if (!ok) return;
    await writeText(filePath, nextContents);
  }
}

async function removeEmptyDirsUpward(startDir: string, stopDir: string): Promise<void> {
  let cur = startDir;
  const stop = path.resolve(stopDir);
  while (path.resolve(cur).startsWith(stop)) {
    const entries = await fs.promises.readdir(cur).catch(() => [] as string[]);
    if (entries.length > 0) break;
    await fs.promises.rmdir(cur).catch(() => undefined);
    const next = path.dirname(cur);
    if (next === cur) break;
    cur = next;
  }
}

export async function deleteRouteForPageId(opts: NextjsCodegenOptions, pageId: string): Promise<void> {
  const layout = getNextjsLayout(opts);
  const dir = routeDirForPageId(layout.appDir, pageId);
  const filePath = path.join(dir, 'page.tsx');

  const existing = await safeReadText(filePath);
  if (!existing) return;

  const isGenerated = isAggoGeneratedFile(existing);
  if (!isGenerated && opts.confirm) {
    const ok = await opts.confirm(`Next.js route exists but is not marked as generated: ${path.relative(opts.runtimeCwdAbs, filePath)}. Delete anyway?`, 'delete');
    if (!ok) return;
  }

  if (isGenerated && opts.confirm) {
    const ok = await opts.confirm(`Delete generated Next.js route for page '${normalizePageId(pageId)}'?`, 'delete');
    if (!ok) return;
  }

  await fs.promises.unlink(filePath).catch(() => undefined);
  await removeEmptyDirsUpward(dir, path.join(layout.appDir, 'aggo', 'page'));
}

export async function syncNextjsRoutes(opts: NextjsCodegenOptions, pageIds: string[]): Promise<void> {
  await ensureRuntimeGeneratedFiles(opts);
  const uniqueIds = Array.from(new Set(pageIds.map(normalizePageId))).filter(Boolean);

  for (const id of uniqueIds) {
    await ensureRouteForPageId(opts, id);
  }
}
