let parseJsonc: ((text: string) => any) | undefined;
try {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const jsonc = require('jsonc-parser');
  parseJsonc = jsonc.parse;
} catch (err) {
  // Not available in some packaged environments if node_modules were not included; fallback below
}

type JSONSchema = any; // Keep this loose - matches the webview/list code expectations

function inferStringSchema(str: string): JSONSchema {
  const formats: Record<string, RegExp> = {
    date: /^\d{4}-\d{2}-\d{2}$/, 
    'date-time': /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?$/,
    email: /^[^@]+@[^@]+\.[^@]+$/,
    uuid: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
    uri: /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/i,
  };
  for (const [format, regex] of Object.entries(formats)) {
    if (regex.test(str)) return { type: 'string', format };
  }
  return { type: 'string' };
}

function inferNumberSchema(n: number) { return Number.isInteger(n) ? { type: 'integer' } : { type: 'number' }; }

function merge(a: JSONSchema, b: JSONSchema): JSONSchema {
  if (JSON.stringify(a) === JSON.stringify(b)) return a;
  if (a.type === 'integer' && b.type === 'number') return { type: 'number' };
  if (a.type === 'number' && b.type === 'integer') return { type: 'number' };
  return { oneOf: [a, b] };
}

export function inferSchema(value: any): JSONSchema {
  if (value === null) return { type: 'null' };
  if (Array.isArray(value)) {
    if (value.length === 0) return { type: 'array', items: {} };
    const items = value.map(inferSchema);
    // try to unify items
    const first = items[0];
    const allSame = items.every((s) => JSON.stringify(s) === JSON.stringify(first));
    if (allSame) return { type: 'array', items: first, minItems: 0 };
    const unique = [...new Map(items.map((s) => [JSON.stringify(s), s])).values()];
    return { type: 'array', items: unique.length === 1 ? unique[0] : { oneOf: unique }, minItems: 0 };
  }
  switch (typeof value) {
    case 'string': return inferStringSchema(value);
    case 'number': return inferNumberSchema(value);
    case 'boolean': return { type: 'boolean' };
    case 'object': {
      const props: Record<string, JSONSchema> = {};
      const required: string[] = [];
      for (const [k, v] of Object.entries(value)) {
        props[k] = inferSchema(v);
        if (v !== undefined && v !== null) required.push(k);
      }
      return { type: 'object', properties: props, required: required.length ? required.sort() : undefined };
    }
    default: return {};
  }
}

export function createSchemaFromJson(jsonObject: any): JSONSchema {
  const root = inferSchema(jsonObject);
  const schema: any = {
    $schema: 'https://json-schema.org/draft-07/schema',
    title: 'Inferred Schema',
    description: 'Generated by Aggo infer command',
  };
  if (root.type === 'object' || root.properties) {
    schema.type = 'object';
    schema.properties = root.properties;
    if (root.required) schema.required = root.required;
  } else if (root.type === 'array' || root.items) {
    schema.type = 'array';
    schema.items = root.items;
  } else if (root.type) {
    schema.type = 'object';
    schema.properties = { value: root };
    schema.required = ['value'];
  } else {
    schema.type = 'object';
  }
  return schema;
}

export function parseJsonText(text: string) {
  if (parseJsonc) {
    try { return parseJsonc(text); } catch (_e) { }
  }
  // Fallback to using standard JSON.parse if jsonc-parser isn't available or fails
  return JSON.parse(text);
}
